import { supabase } from '../config/supabase.js';

// ============================================
// TABLE STRUCTURES (for reference)
// ============================================

/*
TABLE: prop_firm_breach_logs
(
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now(),
  user_id uuid references public.users(id),
  challenge_id bigint references public.user_challenges(id),
  mt5_account_id text,
  breach_type text,
  breach_value numeric,
  threshold_value numeric,
  description text,
  email_sent boolean default false
);

TABLE: prop_firm_email_templates
(
  id bigint generated by default as identity primary key,
  created_at timestamp with time zone default now(),
  template_name text not null,
  subject text not null,
  body text not null
);
*/

// ============================================
// SERVICE FUNCTIONS
// ============================================

/**
 * Fetches all users with active challenges and their MT5 accounts.
 */
const getTraders = async () => {
  const { data, error } = await supabase
    .from('user_challenges')
    .select(`
      id,
      status,
      created_at,
      users!inner (
        id,
        email,
        user_profile!inner (
          full_name
        )
      ),
      mt5_accounts!inner (
        id,
        login,
        balance,
        equity
      ),
      challenge_types!inner (
        name
      )
    `)
    .in('status', ['Active', 'Breached']); // Fetch both active and already breached traders

  if (error) {
    console.error('Error fetching traders from Supabase:', error);
    throw new Error('Failed to fetch traders from database.');
  }

  // Format the data into a flat structure that the frontend expects
  const formattedTraders = data.map(challenge => ({
    id: challenge.id, // Use the user_challenge id as the unique identifier
    user_id: challenge.users.id,
    trader_name: challenge.users.user_profile.full_name || challenge.users.email,
    email: challenge.users.email,
    account_id: challenge.mt5_accounts.login,
    current_balance: challenge.mt5_accounts.balance,
    current_equity: challenge.mt5_accounts.equity,
    account_type: challenge.challenge_types.name,
    status: challenge.status,
    initial_balance: challenge.challenge_types.name.includes('10K') ? 10000 : 100000 // Example logic
  }));

  return formattedTraders;
};


/**
 * Checks a single trader's account for any rule breaches.
 */
const checkBreaches = async (trader, rules, dailyStats) => {
    const breaches = [];
    const initialBalance = trader.initial_balance;

    // 1. Max Total Loss Check
    const maxTotalLossPercent = rules.find(r => r.rule_name === 'Max Total Loss')?.rule_value || 10;
    const maxTotalLoss = initialBalance * (maxTotalLossPercent / 100);
    const totalDrawdown = initialBalance - trader.current_equity;

    if (totalDrawdown > maxTotalLoss) {
        breaches.push({
            breach_type: 'Max Total Loss',
            breach_value: (totalDrawdown / initialBalance) * 100,
            threshold_value: maxTotalLossPercent,
            description: `Account equity dropped to $${trader.current_equity.toFixed(2)}, exceeding the max loss limit of $${maxTotalLoss.toFixed(2)}.`,
        });
    }

    // 2. Max Daily Loss Check
    if (dailyStats && dailyStats.length > 0) {
        const latestDailyStat = dailyStats[0];
        const maxDailyLossPercent = rules.find(r => r.rule_name === 'Max Daily Loss')?.rule_value || 5;
        
        if (latestDailyStat.daily_drawdown_percentage > maxDailyLossPercent) {
             breaches.push({
                breach_type: 'Max Daily Loss',
                breach_value: latestDailyStat.daily_drawdown_percentage,
                threshold_value: maxDailyLossPercent,
                description: `Account recorded a daily loss of ${latestDailyStat.daily_drawdown_percentage.toFixed(2)}%, exceeding the limit of ${maxDailyLossPercent}%.`,
            });
        }
    }

    return breaches;
};

/**
 * Logs a detected breach into the database.
 */
const logBreach = async (breachData) => {
  const { data, error } = await supabase
    .from('prop_firm_breach_logs')
    .insert([breachData])
    .select();

  if (error) {
    console.error('Error logging breach:', error);
    return null;
  }
  return data[0];
};

/**
 * Updates the status of a user's challenge (e.g., to 'Breached' or 'Terminated').
 */
const updateUserChallengeStatus = async (challengeId, newStatus) => {
  const { data, error } = await supabase
    .from('user_challenges')
    .update({ status: newStatus })
    .eq('id', challengeId)
    .select();

  if (error) {
    console.error(`Error updating challenge status to ${newStatus}:`, error);
    return null;
  }
  return data[0];
};


export {
  getTraders,
  checkBreaches,
  logBreach,
  updateUserChallengeStatus,
};
